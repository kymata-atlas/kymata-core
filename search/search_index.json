{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"getting-started/","title":"Getting started with Kymata Core","text":""},{"location":"getting-started/#set-up","title":"Set Up","text":"<p>This provides an overview of how to set up Kymata Core locally.</p> <p>Please be aware that this codebase is released publicly to ensure the transparency of the results in the Kymata Atlas. While  we welcome users using this codebase, we are unable to prioritise installation support.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python</li> </ul> <p>Confirm you have the correct version of Python installed. Type    <pre><code>$ pyenv versions\n</code></pre>    This should confirm that python 3.11 or above is installed. If it isn't already there,    install it using <code>pyenv install</code>. You should be able to confirm    you are using the correct version using    <pre><code>$ python -V\n</code></pre></p> <ul> <li>Poetry</li> </ul> <p>This package uses Poetry to manage packages. See python-poetry.org for installation instructions.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<ol> <li>Clone this repository:    <pre><code>$ git clone https://github.com/kymata-atlas/kymata-core.git\n</code></pre></li> <li> <p>To install the python packages you will need to use Poetry. Assuming you have installed Poetry,     type:    <pre><code>$ poetry install\n</code></pre>    to load the pakages needed.</p> </li> <li> <p>At this point, you should be able to either run the xx from the terminal    <pre><code>$ poetry run invokers/run_gridsearch.py\n</code></pre>    or activate in this environment in an IDE such as PyCharm.</p> </li> </ol>"},{"location":"getting-started/#running-tests-linting-and-generating-documentation","title":"Running tests, linting, and generating documentation","text":"<p>This will be done automatically via Github actions.</p> <p>To run the tests manually, run: <pre><code>$ poetry run pytest\n</code></pre> To run linting manually, run: <pre><code>$ poetry run ruff check\n</code></pre> To serve the documentation locally, run: <pre><code>$ poetry run mkdocs serve check\n</code></pre></p>"},{"location":"getting-started/#analysing-a-dataset-with-kymata","title":"Analysing a dataset with Kymata","text":""},{"location":"getting-started/#1-locate-your-raw-emeg-dataset","title":"1. Locate your raw EMEG dataset","text":"<p>You'll need the following files:</p> <ul> <li><code>&lt;participant_name&gt;_run1_raw.fif</code></li> <li><code>&lt;participant_name&gt;_recording_config.yaml</code></li> </ul>"},{"location":"getting-started/#2-preprocess-the-data","title":"2. Preprocess the data","text":"<p>Kymata Core holds the Kymata preprocessing code that comprises the 'Kymata back-end', including preprocessing steps, gridsearch procedures, expression plotting and IPPM generation.</p> <p>Run the following invokers from <code>invokers/</code> in order:</p> <ul> <li><code>invoker_run_data_cleansing.py</code></li> <li>This does:<ol> <li>first-pass filtering </li> <li>maxfiltering</li> <li>second-pass filtering</li> <li>eog removal</li> </ol> </li> <li><code>invoker_create_trialwise_data.py</code></li> <li>This does:<ol> <li>Splits the data into trials</li> </ol> </li> <li>This is all you need for sensor-space gridsearch.</li> <li><code>invoker_run_hexel_current_estimation.py</code></li> <li><code>invoker_estimate_noise_covariance.py</code></li> <li>This is only necessary if running the gridsearch in source space (hexels).</li> </ul>"},{"location":"getting-started/#3-run-the-gridsearch","title":"3. Run the gridsearch","text":"<p>Run the following invoker from invokers/:</p> <pre><code>invokers/run_gridsearch.py\n</code></pre> <p>This will output a <code>.nkg</code> file, which can then be loaded (see <code>demos/demo_save_load.ipynb</code>).</p> <p>Notes</p> <p>If running at the CBU, an easier way to do this (see Troubleshooting) may be to use the shell script <code>submit_gridsearch.sh</code>, which sets up the Apptainer environment the right way. Either run it locally with <code>./submit_gridsearch.sh</code>, or run it on the CBU queue with <code>sbatch submit_gridsearch.sh</code>.</p>"},{"location":"getting-started/#4-plot-the-results","title":"4. Plot the results","text":"<ul> <li><code>invoker_run_nkg_plotting.py</code></li> </ul> <p>See also <code>demos/demo_plotting.ipynb</code>.</p>"},{"location":"getting-started/#5-visualise-processing-pathways","title":"5. Visualise processing pathways","text":"<p>See <code>demos/demo_ippm.ipynb</code>.</p> <p></p>"},{"location":"getting-started/#troubleshooting-on-the-cbu-compute-cluster","title":"Troubleshooting on the CBU compute cluster","text":"<ul> <li>You see <code>Acccess denied permission error: 403</code> when you try to use github.</li> </ul> <p>This is because your git instance at the CBU is not passing the correct authorisation credentials to your GitHub account. You will have to create a new public key in ~/.ssh/ in your cbu home folder, and then use this to create an SSH key in your github settings.</p> <p>Then, create (or modify) the <code>config</code> file in <code>~/.ssh/</code>:</p> <pre><code>Host github.com\n        LogLevel DEBUG3\n        User git\n        Hostname github.com\n        PreferredAuthentications publickey\n        IdentityFile /home/&lt;username&gt;/.ssh/&lt;name of private key&gt;\n</code></pre> <ul> <li>You see <code>ModuleNotFoundError: No module named 'numpy'</code></li> </ul> <p>You are probably running <code>submit_gridsearch.sh</code>, and it currently has Andy's <code>kymata-core</code> location hard-coded. Update to point it at your copy.</p> <ul> <li>You want to print offscreen.</li> </ul> <p>If plotting on the CBU cluster (off-screen), use</p> <pre><code>xvfb-run -a poetry run python -m kymata.invokers.invoker_run_nkg_plotting\n</code></pre>"},{"location":"overview/","title":"Overview of Kymata Core","text":"<p>Kymata Core is the central codebase used for the generation and maintenance of the Kymata Atlas, kymata.org. It is released as open source in order to maintain openness and transparency in scientific research, and is maintained by the Kymata Research Group.</p> <p>It is comprised of both a python package, <code>kymata</code>, and a number of invokers that instantiate the main Kymata Atlas pipeline, including:</p> <ul> <li>Standard preprocessing and source localisation steps for neural sensor data (MEG, EEG, ECoG);</li> <li>Gridsearch approaches for transform mapping;</li> <li>Information Processing Pathway Map generation (both offline generation and evaluation);</li> <li>Plotting functionality</li> </ul> <p>The codebase is released publicly to ensure the transparency of the results in the Atlas. While comments and issues are welcomed, we are unable to prioritise installation support.</p> <p>  Go to the Github repository Go to code documentation</p>"},{"location":"overview/#citing-the-codebase-or-the-kymata-package","title":"Citing the codebase or the <code>kymata</code> package","text":"<p>Please use the following reference in all citations: </p> <p>T.B.C</p>"},{"location":"overview/#usage","title":"Usage","text":"<p>Please refer to the documentation, or see the <code>demos/</code> folder for example code, including test data.</p>"},{"location":"reference/","title":"Code Reference","text":""},{"location":"reference/#kymata","title":"kymata","text":""},{"location":"reference/#kymata.plot.expression","title":"kymata.plot.expression","text":"<p>Functions:</p> <ul> <li> <code>expression_plot</code>             \u2013              <p>Generates a plot of transform expressions over time with optional display customizations.</p> </li> <li> <code>legend_display_dict</code>             \u2013              <p>Creates a dictionary for the <code>legend_display</code> parameter of <code>expression_plot()</code>.</p> </li> </ul>"},{"location":"reference/#kymata.plot.expression.expression_plot","title":"expression_plot","text":"<pre><code>expression_plot(expression_set: ExpressionSet, show_only: Optional[str | Sequence[str]] = None, paired_axes: bool = True, alpha: float = p_threshold_for_sigmas(5), color: Optional[str | dict[str, str] | list[str]] = None, ylim: Optional[float] = None, xlims: Optional[tuple[float | None, float | None]] = None, hidden_transforms_in_legend: bool = True, title: Optional[str] = None, fig_size: tuple[float, float] = (12, 7), minimap: str | None = None, minimap_type: str = 'inflated', minimap_view: Optional[str] = None, show_only_sensors: Optional[Literal['eeg', 'meg']] = None, minimap_latency_range: Optional[tuple[float | None, float | None]] = None, plot_top_n: Optional[int] = None, save_to: Optional[Path] = None, overwrite: bool = True, show_legend: bool = True, legend_display: dict[str, str] | None = None, minimap_kwargs: Optional[dict] = None) -&gt; Figure\n</code></pre> <p>Generates a plot of transform expressions over time with optional display customizations.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>pyplot.Figure: The matplotlib figure object containing the generated plot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If the file already exists at save_to and overwrite is set to False.</p> </li> </ul> Notes <p>The function plots the expression data with options to customize the appearance and statistical significance thresholds. It supports different data types (e.g., HexelExpressionSet, SensorExpressionSet) and can handle paired axes for left/right hemisphere data.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(expression_set)","title":"<code>expression_set</code>","text":"(<code>ExpressionSet</code>)           \u2013            <p>The set of expressions to plot, containing transforms and associated data.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(show_only)","title":"<code>show_only</code>","text":"(<code>Optional[str | Sequence[str]]</code>, default:                   <code>None</code> )           \u2013            <p>A string or a sequence of strings specifying which transforms to plot. If None, all transforms in the expression_set will be plotted. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(paired_axes)","title":"<code>paired_axes</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>When True, shows the expression plot split into left and right axes. When False, all points are shown on the same axis. Default is True.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(alpha)","title":"<code>alpha</code>","text":"(<code>float</code>, default:                   <code>p_threshold_for_sigmas(5)</code> )           \u2013            <p>Significance level for statistical tests, defaulting to a 5-sigma threshold.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(color)","title":"<code>color</code>","text":"(<code>Optional[str | dict[str, str] | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Color settings for the plot. Can be a single color, a dictionary mapping transform names to colors, or a list of colors. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(ylim)","title":"<code>ylim</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The y-axis limit (p-value). Use log10 of the desired value \u2014 e.g. if the desired limit is 10^-100, supply ylim=-100. If None, it will be determined automatically. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(xlims)","title":"<code>xlims</code>","text":"(<code>tuple[Optional[float], Optional[float]]</code>, default:                   <code>None</code> )           \u2013            <p>The x-axis limits as a tuple (in ms). None to use default values, or set either entry to None to use the default for that value. Default is (-100, 800).</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(hidden_transforms_in_legend)","title":"<code>hidden_transforms_in_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, includes non-plotted transforms in the legend. Default is True.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Title over the top axis in the figure. Supply None for no title. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(fig_size)","title":"<code>fig_size</code>","text":"(<code>tuple[float, float]</code>, default:                   <code>(12, 7)</code> )           \u2013            <p>Figure size in inches. Default is (12, 7).</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(minimap)","title":"<code>minimap</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If None, no minimap is shown. Other options are: <code>\"standard\"</code>: Show small minimal. <code>\"large\"</code>: Show a large minimal with smaller expression plot. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(minimap_type)","title":"<code>minimap_type</code>","text":"(<code>str</code>, default:                   <code>'inflated'</code> )           \u2013            <p>The type of minimap to display. Options include: <code>\"inflated\"</code>, or any other valid keyword for a mne surface: This will plot on a 3D cortical mesh. <code>\"volumetric\"</code>: plot in a volumetric view \u00e0 la MRICron. Default is \"inflated\".</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(minimap_view)","title":"<code>minimap_view</code>","text":"(<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The view type for the minimap, either \"lateral\" or other specified views. Valid options are: <code>\"lateral\"</code>: From the left or right side such that the lateral (outside) surface of the given hemisphere is              visible. <code>\"medial\"</code>: From the left or right side such that the medial (inside) surface of the given hemisphere is             visible (at least when in split or single-hemi mode). <code>\"rostral\"</code>: From the front. <code>\"caudal\"</code>: From the rear. <code>\"dorsal\"</code>: From above, with the front of the brain pointing up. <code>\"ventral\"</code>: From below, with the front of the brain pointing up. <code>\"frontal\"</code>: From the front and slightly lateral, with the brain slightly tilted forward (yielding a view              from slightly above). <code>\"parietal\"</code>: From the rear and slightly lateral, with the brain slightly tilted backward (yielding a view               from slightly above). <code>\"axial\"</code>: From above with the brain pointing up (same as 'dorsal'). <code>\"sagittal\"</code>: From the right side. <code>\"coronal\"</code>: From the rear. Only <code>\"axial\"</code> and <code>\"coronal\"</code> are valid for volumetric view; sagittal views will always be plotted. Default is None (lateral for cortical, axial for volumetric).</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(show_only_sensors)","title":"<code>show_only_sensors</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Show only one type of sensors. \"meg\" for MEG sensors, \"eeg\" for EEG sensors. None to show all sensors. Supplying this value with something other than a SensorExpressionSet causes will throw an exception. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(minimap_latency_range)","title":"<code>minimap_latency_range</code>","text":"(<code>Optional[tuple[float | None, float | None]]</code>, default:                   <code>None</code> )           \u2013            <p>Supply <code>(start_time, stop_time)</code> to restrict the minimap view to only the specified time window, and highlight the time window on the expression plot. Both <code>start_time</code> and <code>stop_time</code> are in seconds. Set <code>start_time</code> or <code>stop_time</code> to <code>None</code> for half-open intervals.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(plot_top_n)","title":"<code>plot_top_n</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>If not None, show only the N most significant sources. If None, plot all significant sources. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(save_to)","title":"<code>save_to</code>","text":"(<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to save the generated plot. If None, the plot is not saved. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, overwrite the existing file if it exists. Default is True.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(show_legend)","title":"<code>show_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, displays the legend. Default is True.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(legend_display)","title":"<code>legend_display</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Allows grouping of multiple transforms under the same legend item. Provide a dictionary mapping true transform names to display names. None applies no grouping. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.expression_plot(minimap_kwargs)","title":"<code>minimap_kwargs</code>","text":"(<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>Keyword argument overrides for minimap plotting. Default is None.</p>"},{"location":"reference/#kymata.plot.expression.legend_display_dict","title":"legend_display_dict","text":"<pre><code>legend_display_dict(transforms: list[str], display_name) -&gt; dict[str, str]\n</code></pre> <p>Creates a dictionary for the <code>legend_display</code> parameter of <code>expression_plot()</code>.</p> <p>This function maps each transform name in the provided list to a single display name, which can be used to group multiple transforms under one legend item in the plot.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary mapping each transform name to the provided display name.</p> </li> </ul>"},{"location":"reference/#kymata.plot.expression.legend_display_dict(transforms)","title":"<code>transforms</code>","text":"(<code>list[str]</code>)           \u2013            <p>A list of transform names to be grouped under the same display name.</p>"},{"location":"reference/#kymata.plot.expression.legend_display_dict(display_name)","title":"<code>display_name</code>","text":"(<code>str</code>)           \u2013            <p>The display name to be used for all transforms in the list.</p>"},{"location":"reference/#kymata.gridsearch.plain","title":"kymata.gridsearch.plain","text":"<p>Functions:</p> <ul> <li> <code>do_gridsearch</code>             \u2013              <p>Perform a grid search over all hexels for all latencies using EMEG data and a given transform.</p> </li> </ul>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch","title":"do_gridsearch","text":"<pre><code>do_gridsearch(emeg_values: NDArray, transform: Transform, channel_names: list, channel_space: str, start_latency: float, emeg_t_start: float, stimulus_shift_correction: float, stimulus_delivery_latency: float, emeg_sample_rate: float, emeg_layout: SensorLayout, plot_location: Optional[Path] = None, n_derangements: int = 1, seconds_per_split: float = 1, n_splits: int = 400, n_reps: int = 1, plot_top_five_channels: bool = False, overwrite: bool = True) -&gt; ExpressionSet\n</code></pre> <p>Perform a grid search over all hexels for all latencies using EMEG data and a given transform.</p> <p>This function processes EMEG data to compute the correlation between sensor or source signals and a specified transform across multiple latencies. The results include statistical significance testing and optional plotting.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ExpressionSet</code> (              <code>ExpressionSet</code> )          \u2013            <p>An ExpressionSet object (either SensorExpressionSet or HexelExpressionSet)</p> </li> <li> <code>ExpressionSet</code>           \u2013            <p>containing the log p-values for each channel/hexel and latency.</p> </li> </ul> Notes <ul> <li>The function down-samples the EMEG data to match the transform's sample rate.</li> <li>The EMEG data is reshaped into segments of the specified duration (<code>seconds_per_split</code>).</li> <li>Cross-correlations between the EMEG data and the transform are computed using FFT.</li> <li>Statistical significance is assessed using a vectorized Welch's t-test.</li> <li>If specified, the results are plotted and saved to the given location.</li> </ul>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(emeg_values)","title":"<code>emeg_values</code>","text":"(<code>NDArray</code>)           \u2013            <p>A 2D array of EMEG values with shape (channels, reps, time).</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(transform)","title":"<code>transform</code>","text":"(<code>Transform</code>)           \u2013            <p>The transform against which the EMEG data will be correlated. It should have a <code>values</code> attribute representing the transform's values and a <code>sample_rate</code> attribute indicating its sample rate.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(channel_names)","title":"<code>channel_names</code>","text":"(<code>list</code>)           \u2013            <p>List of channel names corresponding to the EMEG data. For 'sensor' space, it is a flat list of sensor names. For 'source' space, it is a list containing two lists: left hemisphere and right hemisphere hexel names.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(channel_space)","title":"<code>channel_space</code>","text":"(<code>str</code>)           \u2013            <p>The type of channel space used, either 'sensor' or 'source'.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(start_latency)","title":"<code>start_latency</code>","text":"(<code>float</code>)           \u2013            <p>The starting latency for the grid search in seconds.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(emeg_t_start)","title":"<code>emeg_t_start</code>","text":"(<code>float</code>)           \u2013            <p>The starting time of the EMEG data in seconds.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(stimulus_shift_correction)","title":"<code>stimulus_shift_correction</code>","text":"(<code>float</code>)           \u2013            <p>Correction factor for stimulus shift in seconds per second.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(stimulus_delivery_latency)","title":"<code>stimulus_delivery_latency</code>","text":"(<code>float</code>)           \u2013            <p>Correction offset for stimulus delivery in seconds.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(plot_location)","title":"<code>plot_location</code>","text":"(<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to save the plot of the top five channels of the grid search. If None, plotting is skipped. Default is None.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(emeg_sample_rate)","title":"<code>emeg_sample_rate</code>","text":"(<code>float</code>)           \u2013            <p>The sample rate of the EMEG data in Hertz.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(n_derangements)","title":"<code>n_derangements</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of derangements (random permutations) used to create the null distribution. Default is 1.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(seconds_per_split)","title":"<code>seconds_per_split</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Duration of each split in seconds. Default is 0.5 seconds.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(n_splits)","title":"<code>n_splits</code>","text":"(<code>int</code>, default:                   <code>400</code> )           \u2013            <p>Number of splits used for analysis. Default is 800.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(n_reps)","title":"<code>n_reps</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of repetitions for each split. Default is 1.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(plot_top_five_channels)","title":"<code>plot_top_five_channels</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Plots the p-values and correlation values of the top five channels in the gridsearch. Default is False.</p>"},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to overwrite existing plot files. Default is True.</p>"},{"location":"reference/#kymata.io.nkg","title":"kymata.io.nkg","text":"<p>Functions:</p> <ul> <li> <code>load_expression_set</code>             \u2013              <p>Loads an ExpressionSet from the specified path(s) or open file.</p> </li> <li> <code>save_expression_set</code>             \u2013              <p>Save the given ExpressionSet to a specified path or an already open file.</p> </li> </ul>"},{"location":"reference/#kymata.io.nkg.load_expression_set","title":"load_expression_set","text":"<pre><code>load_expression_set(from_path_or_file: PathType | FileType | list[PathType]) -&gt; ExpressionSet\n</code></pre> <p>Loads an ExpressionSet from the specified path(s) or open file.</p> <p>The function determines the type of ExpressionSet (HexelExpressionSet or SensorExpressionSet) based on the data loaded from the provided path or file. It then constructs and returns an instance of the appropriate ExpressionSet subclass.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ExpressionSet</code> (              <code>ExpressionSet</code> )          \u2013            <p>An instance of either HexelExpressionSet or SensorExpressionSet,                depending on the type identifier in the data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If required keys are missing in the data dictionary.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the type identifier is not recognized.</p> </li> </ul>"},{"location":"reference/#kymata.io.nkg.load_expression_set(from_path_or_file)","title":"<code>from_path_or_file</code>","text":"(<code>PathType | FileType | list[PathType]</code>)           \u2013            <p>The path, file, or list of paths from which to load                                                           the data.</p>"},{"location":"reference/#kymata.io.nkg.save_expression_set","title":"save_expression_set","text":"<pre><code>save_expression_set(expression_set: ExpressionSet, to_path_or_file: PathType | FileType, compression=ZIP_LZMA, overwrite: bool = False)\n</code></pre> <p>Save the given ExpressionSet to a specified path or an already open file.</p> <p>This function saves the ExpressionSet data into a compressed file format. If a file path is provided, it creates and writes to the file. If an open file is supplied, it should be opened in \"wb\" mode. The overwrite flag is ignored if an open file is supplied.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If the specified path already exists and overwrite is False.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the provided path or file type is invalid.</p> </li> </ul> Notes <ul> <li>The compression parameter should be compatible with the <code>ZipFile</code> class.</li> <li>The function writes various metadata and data blocks in a structured format within the zip file.</li> </ul>"},{"location":"reference/#kymata.io.nkg.save_expression_set(expression_set)","title":"<code>expression_set</code>","text":"(<code>ExpressionSet</code>)           \u2013            <p>The ExpressionSet object to be saved.</p>"},{"location":"reference/#kymata.io.nkg.save_expression_set(to_path_or_file)","title":"<code>to_path_or_file</code>","text":"(<code>PathType | FileType</code>)           \u2013            <p>The path or open file where the ExpressionSet will be saved.</p>"},{"location":"reference/#kymata.io.nkg.save_expression_set(compression)","title":"<code>compression</code>","text":"\u2013            <p>The compression method to use (default is ZIP_LZMA).</p>"},{"location":"reference/#kymata.io.nkg.save_expression_set(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allows overwriting an existing file (default is False).</p>"},{"location":"reference/#kymata.io.config","title":"kymata.io.config","text":"<p>Functions:</p> <ul> <li> <code>get_root_dir</code>             \u2013              <p>Get the root directory based on the configuration parameters.</p> </li> <li> <code>load_config</code>             \u2013              <p>Load configuration parameters from a specified path or file.</p> </li> <li> <code>modify_param_config</code>             \u2013              <p>Modify a specific configuration parameter in the given configuration file.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.get_root_dir","title":"get_root_dir","text":"<pre><code>get_root_dir(config: dict) -&gt; str\n</code></pre> <p>Get the root directory based on the configuration parameters.</p> <p>This function returns the appropriate root directory path based on the 'data_location' parameter in the provided configuration dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The root directory path corresponding to the 'data_location' parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the 'data_location' parameter is not 'local', 'cbu', or 'cbu-local'.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.get_root_dir(config)","title":"<code>config</code>","text":"(<code>dict</code>)           \u2013            <p>The configuration dictionary containing the 'data_location' parameter.</p>"},{"location":"reference/#kymata.io.config.load_config","title":"load_config","text":"<pre><code>load_config(config_location: PathType | FileType) -&gt; dict\n</code></pre> <p>Load configuration parameters from a specified path or file.</p> <p>This function reads the configuration parameters from a YAML file located at the given path or open file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>The configuration parameters loaded from the file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the specified path does not exist.</p> </li> <li> <code>YAMLError</code>             \u2013            <p>If there is an error in parsing the YAML file.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.load_config(config_location)","title":"<code>config_location</code>","text":"(<code>PathType | FileType</code>)           \u2013            <p>The path to the configuration file or an open file object.</p>"},{"location":"reference/#kymata.io.config.modify_param_config","title":"modify_param_config","text":"<pre><code>modify_param_config(config_location: str, key: str, value)\n</code></pre> <p>Modify a specific configuration parameter in the given configuration file.</p> <p>This function updates the value of a specified key in the configuration file and saves the changes.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the specified configuration file does not exist.</p> </li> <li> <code>YAMLError</code>             \u2013            <p>If there is an error in parsing the YAML file.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.modify_param_config(config_location)","title":"<code>config_location</code>","text":"(<code>str</code>)           \u2013            <p>The path to the configuration file.</p>"},{"location":"reference/#kymata.io.config.modify_param_config(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the configuration parameter to be modified.</p>"},{"location":"reference/#kymata.io.config.modify_param_config(value)","title":"<code>value</code>","text":"\u2013            <p>The new value to be assigned to the specified key.</p>"},{"location":"reference/#kymata.plot.ippm","title":"kymata.plot.ippm","text":"<p>Functions:</p> <ul> <li> <code>plot_ippm</code>             \u2013              <p>Plots an IPPM graph, always including all available hemispheres.</p> </li> <li> <code>xlims_from_expressionset</code>             \u2013              <p>Get an appropriate set of xlims from an ExpressionSet.</p> </li> </ul>"},{"location":"reference/#kymata.plot.ippm.plot_ippm","title":"plot_ippm","text":"<pre><code>plot_ippm(ippm: IPPM, colors: dict[str, str], title: Optional[str] = None, xlims_s: tuple[Optional[float], Optional[float]] = (None, None), y_ordinate_style: str = centered, connection_style: str = last_to_first, scale_nodes: bool = False, figheight: int = 5, figwidth: int = 10, arrowhead_dims: tuple[float, float] = None, linewidth: float = 3, show_labels: bool = True, relabel: dict[str, str] | None = None, avoid_collinearity: bool = False, _test_hemisphere_colors: bool = False) -&gt; Figure\n</code></pre> <p>Plots an IPPM graph, always including all available hemispheres.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>A figure of the IPPM graph.</p> </li> </ul>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(ippm)","title":"<code>ippm</code>","text":"(<code>IPPM</code>)           \u2013            <p>IPPM object to plot.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(colors)","title":"<code>colors</code>","text":"(<code>dict[str, str]</code>)           \u2013            <p>Dictionary with keys as node names and values as colors in hexadecimal. Contains the color for each transform. The nodes and edges are colored accordingly.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Title of the plot.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(scale_nodes)","title":"<code>scale_nodes</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>scales the node by the significance. Default is False</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(figheight)","title":"<code>figheight</code>","text":"(<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Height of the plot. Defaults to 5.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(figwidth)","title":"<code>figwidth</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Width of the plot. Defaults to 10.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(show_labels)","title":"<code>show_labels</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Show transform names as labels on the graph. Defaults to True.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(relabel)","title":"<code>relabel</code>","text":"(<code>dict[str, str]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary to specify optional labels for each node. Dictionary should map original transform labels to desired labels. Missing keys will be ignored. Defaults to None (no change).</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(avoid_collinearity)","title":"<code>avoid_collinearity</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to apply a small offset to avoid collinearity between nodes in the same serial step. Defaults to False.</p>"},{"location":"reference/#kymata.plot.ippm.plot_ippm(_test_hemisphere_colors)","title":"<code>_test_hemisphere_colors</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overrides the <code>colors</code> dict to color nodes according to their hemisphere, for testing vertical separation. Defaults to False.</p>"},{"location":"reference/#kymata.plot.ippm.xlims_from_expressionset","title":"xlims_from_expressionset","text":"<pre><code>xlims_from_expressionset(es: ExpressionSet, padding: float = 0.05) -&gt; tuple[float, float]\n</code></pre> <p>Get an appropriate set of xlims from an ExpressionSet.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>tuple[float, float]: xmin, xmax</p> </li> </ul>"},{"location":"reference/#kymata.plot.ippm.xlims_from_expressionset(es)","title":"<code>es</code>","text":"(<code>ExpressionSet</code>)           \u2013"},{"location":"reference/#kymata.plot.ippm.xlims_from_expressionset(padding)","title":"<code>padding</code>","text":"(<code>float</code>, default:                   <code>0.05</code> )           \u2013            <p>The amount of padding to add either side of the IPPM plot, in seconds. Default is 0.05 (50ms).</p>"},{"location":"reference/#kymata.ippm.ippm","title":"kymata.ippm.ippm","text":"<p>Classes:</p> <ul> <li> <code>IPPM</code>           \u2013            <p>IPPM container/constructor object. Use this class as an interface to build a single, unified IPPM graph</p> </li> </ul>"},{"location":"reference/#kymata.ippm.ippm.IPPM","title":"IPPM","text":"<pre><code>IPPM(expression_set: ExpressionSet, candidate_transform_list: CandidateTransformList | TransformHierarchy, denoiser: str | None = _default_denoiser, merge_before_denoising: bool = False, **kwargs: dict[str, Any])\n</code></pre> <p>IPPM container/constructor object. Use this class as an interface to build a single, unified IPPM graph from an expression set.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any transform in the hierarchy is not found in the expression set, or if the provided denoiser is invalid.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>set_kids</code>             \u2013              <p>Adds KID attributes to edges and nodes in the IPPM graph based on transform mappings.</p> </li> <li> <code>to_json</code>             \u2013              <p>Serializes the IPPM into a JSON format suitable for sending to ."},{"location":"reference/#kymata.ippm.ippm.IPPM(expression_set)","title":"<code>expression_set</code>","text":"(<code>ExpressionSet</code>)           \u2013            <p>The ExpressionSet from which to build the IPPM.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM(candidate_transform_list)","title":"<code>candidate_transform_list</code>","text":"(<code>CandidateTransformList</code>)           \u2013            <p>The CTL (i.e. underlying hypothetical IPPM) to be applied  to the expression set.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM(denoiser)","title":"<code>denoiser</code>","text":"(<code>str</code>, default:                   <code>_default_denoiser</code> )           \u2013            <p>The denoising method to be applied to the expression set. Default is None.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM(merge_before_denoising)","title":"<code>merge_before_denoising</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, this will merge both hemispheres before running the denoiser.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments passed to the denoiser.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM.set_kids","title":"set_kids","text":"<pre><code>set_kids(transform_kids: dict[str, str], verify_against_api: bool = True) -&gt; None\n</code></pre> <p>Adds KID attributes to edges and nodes in the IPPM graph based on transform mappings.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When verifying against the API (and assuming the API is reachable), if any of the KIDs are not valid.</p> </li> </ul> <p>Warns:</p> <ul> <li> <code>Issues a warning if</code>             \u2013            </li> </ul>"},{"location":"reference/#kymata.ippm.ippm.IPPM.set_kids(transform_kids)","title":"<code>transform_kids</code>","text":"(<code>dict[str, str]</code>)           \u2013            <p>Dictionary mapping transform names to their KID values.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM.set_kids(verify_against_api)","title":"<code>verify_against_api</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (the default), verify all supplied KIDs against the Kymata Atlas API.</p>"},{"location":"reference/#kymata.ippm.ippm.IPPM.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serializes the IPPM into a JSON format suitable for sending to . <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression","title":"kymata.entities.expression","text":"<p>Classes and functions for storing expression information.</p> <p>Classes:</p> <ul> <li> <code>ExpressionPoint</code>           \u2013            <p>A single point of transform expression evidence.</p> </li> <li> <code>ExpressionSet</code>           \u2013            <p>Brain data associated with expression of a single transform.</p> </li> <li> <code>HexelExpressionSet</code>           \u2013            <p>Brain data associated with the expression of a single transform in hexel space.</p> </li> <li> <code>SensorExpressionSet</code>           \u2013            <p>Brain data associated with the expression of a single transform in sensor space.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>combine</code>             \u2013              <p>Combines a sequence of <code>ExpressionSet</code>s into a single <code>ExpressionSet</code>.</p> </li> <li> <code>get_n_channels</code>             \u2013              <p>Returns the number of channels represented in an ExpressionSet.</p> </li> <li> <code>group_points_by_transform</code>             \u2013              <p>Groups a list of expression points by their associated transforms.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.ExpressionPoint","title":"ExpressionPoint","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A single point of transform expression evidence.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet","title":"ExpressionSet","text":"<pre><code>ExpressionSet(transforms: str | Sequence[str], latencies: Sequence[Latency], data_blocks: dict[str, _InputDataArray | Sequence[_InputDataArray]], channel_coord_name: str, channel_coord_dtype, channel_coord_values: dict[str, Sequence])\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Brain data associated with expression of a single transform. Data is log10 p-values.</p> <p>Initializes the ExpressionSet with the provided data.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>when arguments are invalid</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>best_transforms</code>             \u2013              <p>Note that channels for which the best p-value is 1 will be omitted.</p> </li> <li> <code>crop</code>             \u2013              <p>Returns a copy of the ExpressionSet with latencies cropped between the two endpoints (inclusive).</p> </li> <li> <code>rename</code>             \u2013              <p>Renames the transforms and channels within an ExpressionSet.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>latencies</code>               (<code>NDArray[LatencyDType]</code>)           \u2013            <p>Latencies, in seconds.</p> </li> <li> <code>transforms</code>               (<code>list[TransformNameDType]</code>)           \u2013            <p>Transform names.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(transforms)","title":"<code>transforms</code>","text":"(<code>str | Sequence[str]</code>)           \u2013            <p>Transform name, or sequence of names.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(latencies)","title":"<code>latencies</code>","text":"(<code>Sequence[Latency]</code>)           \u2013            <p>Latency values.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(data_blocks)","title":"<code>data_blocks</code>","text":"(<code>dict[str, _InputDataArray | Sequence[_InputDataArray]]</code>)           \u2013            <p>Mapping of block names to data arrays (log10 p-values).</p> <p>In general there are two possible formats for this argument.</p> <p>In the first (safer, more explicit and flexible) format, <code>data_blocks</code> contains a dict mapping block names to data arrays. E.g., in the case there are three transforms in a hexel setting: <pre><code>    {\n                  # each array is (channel, latency)-shaped\n                  # and there's one for each transform\n                  # \u2193\n        \"left\":  [array(...), array(...), array(...)],\n        \"right\": [array(...), array(...), array(...)],\n    }\n</code></pre> or in a sensor setting: <pre><code>    {\n        \"scalp\": [array(...), array(...), array(...)],\n    }\n</code></pre> (and where <code>array(...)</code> can be a numpy array or a sparse array). In this format, all data arrays should be the same size.</p> <p>In the second (more performant) format, <code>data_blocks</code> contains a single data array whose <code>transform</code> dimensions can be concatenated to achieve the desired resultant data block. E.g. <pre><code>    {\n                  # each array is (channel, latency, transform)-shaped\n                  # \u2193\n        \"left\":  array(...),\n        \"right\": array(...),\n    }\n</code></pre></p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(channel_coord_name)","title":"<code>channel_coord_name</code>","text":"(<code>str</code>)           \u2013            <p>Name of the channel coordinate.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(channel_coord_dtype)","title":"<code>channel_coord_dtype</code>","text":"\u2013            <p>Data type of the channel coordinate.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet(channel_coord_values)","title":"<code>channel_coord_values</code>","text":"(<code>dict[str, Sequence]</code>)           \u2013            <p>Dictionary mapping block names to channel coordinate values.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: list[TransformNameDType]\n</code></pre> <p>Transform names.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.best_transforms","title":"best_transforms  <code>abstractmethod</code>","text":"<pre><code>best_transforms() -&gt; list[ExpressionPoint] | tuple[list[ExpressionPoint], ...]\n</code></pre> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.crop","title":"crop  <code>abstractmethod</code>","text":"<pre><code>crop(latency_start: float | None, latency_stop: float | None) -&gt; Self\n</code></pre> <p>Returns a copy of the ExpressionSet with latencies cropped between the two endpoints (inclusive).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>A copy of the ExpressionSet with the latencies cropped between the specified start and stop.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.crop(latency_start)","title":"<code>latency_start</code>","text":"(<code>float | None</code>)           \u2013            <p>Latency in seconds to start the cropped window. Use None for no cropping at the start (e.g. half-open crop).</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.crop(latency_stop)","title":"<code>latency_stop</code>","text":"(<code>float | None</code>)           \u2013            <p>Latency in seconds to stop the cropped window. Use None for no cropping at the end (e.g. half-open crop).</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.rename","title":"rename","text":"<pre><code>rename(transforms: dict[str, str] = None, channels: dict = None) -&gt; None\n</code></pre> <p>Renames the transforms and channels within an ExpressionSet.</p> <p>Supply a dictionary mapping old values to new values.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a transform name in the expression set.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet","title":"HexelExpressionSet","text":"<pre><code>HexelExpressionSet(transforms: str | Sequence[str], hexels_lh: Sequence[Hexel], hexels_rh: Sequence[Hexel], latencies: Sequence[Latency], data_lh: _InputDataArray | Sequence[_InputDataArray], data_rh: _InputDataArray | Sequence[_InputDataArray])\n</code></pre> <p>               Bases: <code>ExpressionSet</code></p> <p>Brain data associated with the expression of a single transform in hexel space. Includes lh, rh, flipped, non-flipped. Data is log10 p-values</p> <p>Methods:</p> <ul> <li> <code>best_transforms</code>             \u2013              <p>Return a pair of DataFrames (left, right), containing:</p> </li> <li> <code>rename</code>             \u2013              <p>Renames the transforms and channels within an ExpressionSet.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>hexels_left</code>               (<code>NDArray[HexelDType]</code>)           \u2013            <p>Hexels, canonical ID.</p> </li> <li> <code>hexels_right</code>               (<code>NDArray[HexelDType]</code>)           \u2013            <p>Hexels, canonical ID.</p> </li> <li> <code>latencies</code>               (<code>NDArray[LatencyDType]</code>)           \u2013            <p>Latencies, in seconds.</p> </li> <li> <code>left</code>               (<code>DataArray</code>)           \u2013            <p>Left-hemisphere data.</p> </li> <li> <code>right</code>               (<code>DataArray</code>)           \u2013            <p>Right-hemisphere data.</p> </li> <li> <code>transforms</code>               (<code>list[TransformNameDType]</code>)           \u2013            <p>Transform names.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.hexels_left","title":"hexels_left  <code>property</code>","text":"<pre><code>hexels_left: NDArray[HexelDType]\n</code></pre> <p>Hexels, canonical ID.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.hexels_right","title":"hexels_right  <code>property</code>","text":"<pre><code>hexels_right: NDArray[HexelDType]\n</code></pre> <p>Hexels, canonical ID.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.left","title":"left  <code>property</code>","text":"<pre><code>left: DataArray\n</code></pre> <p>Left-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.right","title":"right  <code>property</code>","text":"<pre><code>right: DataArray\n</code></pre> <p>Right-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: list[TransformNameDType]\n</code></pre> <p>Transform names.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.best_transforms","title":"best_transforms","text":"<pre><code>best_transforms() -&gt; tuple[list[ExpressionPoint], list[ExpressionPoint]]\n</code></pre> <p>Return a pair of DataFrames (left, right), containing: for each hexel, the best transform and latency for that hexel, and the associated log p-value</p> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.rename","title":"rename","text":"<pre><code>rename(transforms: dict[str, str] = None, channels: dict = None) -&gt; None\n</code></pre> <p>Renames the transforms and channels within an ExpressionSet.</p> <p>Supply a dictionary mapping old values to new values.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a transform name in the expression set.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet","title":"SensorExpressionSet","text":"<pre><code>SensorExpressionSet(transforms: str | Sequence[str], sensors: Sequence[Sensor], latencies: Sequence[Latency], data: _InputDataArray | Sequence[_InputDataArray], sensor_layout: Optional[SensorLayout] = None)\n</code></pre> <p>               Bases: <code>ExpressionSet</code></p> <p>Brain data associated with the expression of a single transform in sensor space. Includes left hemisphere (lh), right hemisphere (rh), flipped, and non-flipped data. Data is represented as log10 p-values.</p> <p>Initialize the SensorExpressionSet with transform names, sensor metadata, latency information, and log p-value data.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>best_transforms</code>             \u2013              <p>Return a DataFrame containing:</p> </li> <li> <code>rename</code>             \u2013              <p>Renames the transforms and channels within an ExpressionSet.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>latencies</code>               (<code>NDArray[LatencyDType]</code>)           \u2013            <p>Latencies, in seconds.</p> </li> <li> <code>scalp</code>               (<code>DataArray</code>)           \u2013            <p>Get the left-hemisphere data.</p> </li> <li> <code>sensors</code>               (<code>NDArray[SensorDType]</code>)           \u2013            <p>Get the sensor metadata.</p> </li> <li> <code>transforms</code>               (<code>list[TransformNameDType]</code>)           \u2013            <p>Transform names.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet(transforms)","title":"<code>transforms</code>","text":"(<code>str | Sequence[str]</code>)           \u2013            <p>The names of the transforms being evaluated.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet(sensors)","title":"<code>sensors</code>","text":"(<code>Sequence[Sensor]</code>)           \u2013            <p>Metadata about the sensors used in the study.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet(latencies)","title":"<code>latencies</code>","text":"(<code>Sequence[Latency]</code>)           \u2013            <p>Latency information corresponding to the data.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet(data)","title":"<code>data</code>","text":"(<code>_InputDataArray | Sequence[_InputDataArray]</code>)           \u2013            <p>Log p-values representing the data.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet(sensor_layout)","title":"<code>sensor_layout</code>","text":"(<code>Optional[SensorLayout]</code>, default:                   <code>None</code> )           \u2013            <p>Layout of the EMEG sensors. None indicates that the layout is not specified. If not None, then expect at least one of MEG and EEG sensors to be specified</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.scalp","title":"scalp  <code>property</code>","text":"<pre><code>scalp: DataArray\n</code></pre> <p>Get the left-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.sensors","title":"sensors  <code>property</code>","text":"<pre><code>sensors: NDArray[SensorDType]\n</code></pre> <p>Get the sensor metadata.</p> <p>Returns:</p> <ul> <li> <code>NDArray[SensorDType]</code>           \u2013            <p>NDArray[SensorDType]: Array of sensor metadata.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: list[TransformNameDType]\n</code></pre> <p>Transform names.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.best_transforms","title":"best_transforms","text":"<pre><code>best_transforms() -&gt; list[ExpressionPoint]\n</code></pre> <p>Return a DataFrame containing: for each sensor, the best transform and latency for that sensor, and the associated log p-value</p> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.rename","title":"rename","text":"<pre><code>rename(transforms: dict[str, str] = None, channels: dict = None) -&gt; None\n</code></pre> <p>Renames the transforms and channels within an ExpressionSet.</p> <p>Supply a dictionary mapping old values to new values.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a transform name in the expression set.</p>"},{"location":"reference/#kymata.entities.expression.combine","title":"combine","text":"<pre><code>combine(expression_sets: Sequence[T_ExpressionSetSubclass]) -&gt; T_ExpressionSetSubclass\n</code></pre> <p>Combines a sequence of <code>ExpressionSet</code>s into a single <code>ExpressionSet</code>. All must be suitable for combination, e.g. same type, same channels, etc.</p>"},{"location":"reference/#kymata.entities.expression.get_n_channels","title":"get_n_channels","text":"<pre><code>get_n_channels(es: ExpressionSet) -&gt; int\n</code></pre> <p>Returns the number of channels represented in an ExpressionSet.</p>"},{"location":"reference/#kymata.entities.expression.group_points_by_transform","title":"group_points_by_transform","text":"<pre><code>group_points_by_transform(points: Iterable[ExpressionPoint]) -&gt; GroupedPoints\n</code></pre> <p>Groups a list of expression points by their associated transforms.</p> <p>This function organizes expression points into a dictionary, where each key is a transform, and each value is a list of expression points associated with that transform.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GroupedPoints</code> (              <code>GroupedPoints</code> )          \u2013            <p>A dictionary mapping transform names to lists of expression points associated with each transform.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.group_points_by_transform(points)","title":"<code>points</code>","text":"(<code>list[ExpressionPoint]</code>)           \u2013            <p>A list of expression points to be grouped.</p>"}]}